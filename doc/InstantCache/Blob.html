<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />

  <title>Class: InstantCache::Blob</title>

  <link rel="stylesheet" href="../rdoc.css" type="text/css" media="screen" />

  <script src="../js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/darkfish.js" type="text/javascript" charset="utf-8"></script>

</head>
<body id="top" class="class">

  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="../index.html">Home</a>
          <a href="../index.html#classes">Classes</a>
          <a href="../index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="../lib/instantcache_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/instantcache.rb">lib/instantcache.rb</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link">Object</p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-memcached_accessor">::memcached_accessor</a></li>
          
          <li><a href="#method-c-memcached_reader">::memcached_reader</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-i-create_identity">#create_identity</a></li>
          
          <li><a href="#method-i-destroy-21">#destroy!</a></li>
          
          <li><a href="#method-i-destroyed-3F">#destroyed?</a></li>
          
          <li><a href="#method-i-get">#get</a></li>
          
          <li><a href="#method-i-lock">#lock</a></li>
          
          <li><a href="#method-i-name">#name</a></li>
          
          <li><a href="#method-i-read">#read</a></li>
          
          <li><a href="#method-i-reset">#reset</a></li>
          
          <li><a href="#method-i-set">#set</a></li>
          
          <li><a href="#method-i-to_s">#to_s</a></li>
          
          <li><a href="#method-i-unlock">#unlock</a></li>
          
          <li><a href="#method-i-write">#write</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      
      <div id="fileindex-section" class="section project-section">
        <h3 class="section-header">Files</h3>
        <ul>
        
          <li class="file"><a href="../History_txt.html">History.txt</a></li>
        
          <li class="file"><a href="../Manifest_txt.html">Manifest.txt</a></li>
        
          <li class="file"><a href="../PostInstall_txt.html">PostInstall.txt</a></li>
        
        </ul>
      </div>
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="../images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="../InstantCache.html">InstantCache</a></li>
        
          <li><a href="../InstantCache/Blob.html">InstantCache::Blob</a></li>
        
          <li><a href="../InstantCache/Counter.html">InstantCache::Counter</a></li>
        
          <li><a href="../InstantCache/CounterIntegerOnly.html">InstantCache::CounterIntegerOnly</a></li>
        
          <li><a href="../InstantCache/Destroyed.html">InstantCache::Destroyed</a></li>
        
          <li><a href="../InstantCache/Exception.html">InstantCache::Exception</a></li>
        
          <li><a href="../InstantCache/IncompatibleType.html">InstantCache::IncompatibleType</a></li>
        
          <li><a href="../InstantCache/IncompleteException.html">InstantCache::IncompleteException</a></li>
        
          <li><a href="../InstantCache/LockInconsistency.html">InstantCache::LockInconsistency</a></li>
        
          <li><a href="../InstantCache/SharedOnly.html">InstantCache::SharedOnly</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="class">InstantCache::Blob</h1>

    <div id="description" class="description">
      
<p>The ‘Blob’ class is used to store data of arbitrary and opaque format
in the cache.  This is used for just about all cases except integer
counters, which have their own class.</p>

    </div><!-- description -->

    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="RESET_VALUE">RESET_VALUE</a></dt>
          
          <dd class="description"><p>When a cached value of this type is reset or cleared, exactly what value is
used to do so?  This is overridden in subclasses as needed.</p></dd>
          
        
        </dl>
      </div>
      

      
      <!-- Attributes -->
      <div id="attribute-method-details" class="method-section section">
        <h3 class="section-header">Attributes</h3>

        
        <div id="expiry-attribute-method" class="method-detail">
          <a name="expiry"></a>
          
          <a name="expiry="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">expiry</span><span
              class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>Memcache expiration (lifetime) for this entity.  Defaults to zero.</p>
          
          </div>
        </div>
        
        <div id="identity-attribute-method" class="method-detail">
          <a name="identity"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">identity</span><span
              class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>When we lock a cell in the shared cache, we do so by creating another cell
with a related name, in which we store info about ourself so that problems
can be traced back to the correct thread/process/system.  That identity is
stored here.</p>
          
          </div>
        </div>
        
        <div id="locked_by_us-attribute-method" class="method-detail">
          <a name="locked_by_us"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">locked_by_us</span><span
              class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>When we lock a memcached cell, not only do we hang our identity on a
interlock cell, but we record the fact locally.</p>
          
          </div>
        </div>
        
        <div id="rawmode-attribute-method" class="method-detail">
          <a name="rawmode"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">rawmode</span><span
              class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>@rawmode is used to signal whether the object is a counter or not. 
Counters require memcache raw mode in order for increment/decrement to
work; non-raw values are marshalled before storage and hence not atomically
accessible in a short instruction stream.</p>
          
          </div>
        </div>
        
      </div><!-- attribute-method-details -->
      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="memcached_accessor-method" class="method-detail ">
          <a name="method-c-memcached_accessor"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">memcached_accessor(<i>symbol</i>[,...])</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">memcached_accessor(<i>symbol</i>[,...]) { |symbol| ... }</span>
            
          </div>
          
          

          <div class="method-description">
            
            <h3>Description</h3>

<p>Access method declarator for a read/write memcache-backed variable.</p>

<p>This declarator sets up several methods relating to the variable.  If the
name passed is <b><tt>:ivar</tt></b>, these methods are created for it:</p>
<dl class="rdoc-list"><dt><em>ivar</em></dt>
<dd>
<p>Normal read accessor (<em>e.g.</em>, <tt>obj.ivar</tt>). (See <a
href="Blob.html#method-i-set">Blob#set</a>)</p>
</dd><dt><em>ivar</em>=</dt>
<dd>
<p>Normal write accessor (<em>e.g.</em>, <tt>obj.ivar = 17</tt>). (See <a
href="Blob.html#method-i-get">Blob#get</a>)</p>
</dd><dt><em>ivar</em>_reset</dt>
<dd>
<p>Resets the cache variable to the default ‘uninitialised’ value. (See <a
href="Blob.html#method-i-reset">Blob#reset</a>)</p>
</dd><dt><em>ivar</em>_expiry</dt>
<dd>
<p>Returns the current cache lifetime (default 0). (See <a
href="Blob.html#attribute-i-expiry">Blob#expiry</a>)</p>
</dd><dt><em>ivar</em>_expiry=</dt>
<dd>
<p>Sets the cache lifetime. (See <a
href="Blob.html#attribute-i-expiry">Blob#expiry=</a>)</p>
</dd><dt><em>ivar</em>_lock</dt>
<dd>
<p>Tries to get an exclusive lock on the variable. (See <a
href="Blob.html#method-i-lock">Blob#lock</a>)</p>
</dd><dt><em>ivar</em>_unlock</dt>
<dd>
<p>Unlocks the variable if locked. (See <a
href="Blob.html#method-i-unlock">Blob#unlock</a>)</p>
</dd><dt><em>ivar</em>_destroyed?</dt>
<dd>
<p>Returns true if variable is disconnected from the cache and unusable. (See
<a href="Blob.html#method-i-destroyed-3F">Blob#destroyed?</a>)</p>
</dd><dt><em>ivar</em>_destroy!</dt>
<dd>
<p>Disconnects the variable from the cache and makes it unusable. (See <a
href="Blob.html#method-i-destroy-21">Blob#destroy!</a>)</p>
</dd></dl>

<h3>Arguments</h3>
<dl class="rdoc-list"><dt><em>symbol</em></dt>
<dd>
<p>As with other Ruby accessor declarations, the argument list consists of one
or more variable names represented as symbols (<em>e.g.</em>,
<tt>:variablename</tt>).</p>
</dd><dt><em>{block}</em></dt>
<dd>
<p>If a block is supplied, its return value must be a string, which will be
used as the name of the memcached cell backing the variable.  The argument
to the block is the name of the variable as passed to the accessor
declaration.</p>
</dd></dl>

<h3>Exceptions</h3>

<p><em>None.</em></p>
            

            
            <div class="method-source-code" id="memcached_accessor-source">
<pre>
<span class="ruby-comment"># File lib/instantcache.rb, line 264</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">memcached_accessor</span>(*<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">block</span>) ; <span class="ruby-keyword">end</span></pre>
            </div><!-- memcached_accessor-source -->
            
          </div>

          

          
        </div><!-- memcached_accessor-method -->

      
        <div id="memcached_reader-method" class="method-detail ">
          <a name="method-c-memcached_reader"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">memcached_reader(<i>symbol</i>[,...])</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">memcached_reader(<i>symbol</i>[,...]) { |symbol| ... }</span>
            
          </div>
          
          

          <div class="method-description">
            
            <h3>Description</h3>

<p>Access method declarator for a read-only memcache-backed variable.</p>

<p>This declarator sets up several methods relating to the variable.  If the
name passed is <b><tt>:ivar</tt></b>, these methods are created for it:</p>
<dl class="rdoc-list"><dt><em>ivar</em></dt>
<dd>
<p>Normal read accessor (<em>e.g.</em>, <tt>obj.ivar</tt>). (See <a
href="Blob.html#method-i-get">Blob#get</a>)</p>
</dd><dt><em>ivar</em>_reset</dt>
<dd>
<p>Resets the cache variable to the default ‘uninitialised’ value. (See <a
href="Blob.html#method-i-reset">Blob#reset</a>)</p>
</dd><dt><em>ivar</em>_expiry</dt>
<dd>
<p>Returns the current cache lifetime (default 0). (See <a
href="Blob.html#attribute-i-expiry">Blob#expiry</a>)</p>
</dd><dt><em>ivar</em>_expiry=</dt>
<dd>
<p>Sets the cache lifetime. (See <a
href="Blob.html#attribute-i-expiry">Blob#expiry=</a>)</p>
</dd><dt><em>ivar</em>_lock</dt>
<dd>
<p>Tries to get an exclusive lock on the variable. (See <a
href="Blob.html#method-i-lock">Blob#lock</a>)</p>
</dd><dt><em>ivar</em>_unlock</dt>
<dd>
<p>Unlocks the variable if locked. (See <a
href="Blob.html#method-i-unlock">Blob#unlock</a>)</p>
</dd><dt><em>ivar</em>_destroyed?</dt>
<dd>
<p>Returns true if variable is disconnected from the cache and unusable. (See
<a href="Blob.html#method-i-destroyed-3F">Blob#destroyed?</a>)</p>
</dd><dt><em>ivar</em>_destroy!</dt>
<dd>
<p>Disconnects the variable from the cache and makes it unusable. (See <a
href="Blob.html#method-i-destroy-21">Blob#destroy!</a>)</p>
</dd></dl>

<h3>Arguments</h3>
<dl class="rdoc-list"><dt><em>symbol</em></dt>
<dd>
<p>As with other Ruby accessor declarations, the argument list consists of one
or more variable names represented as symbols (<em>e.g.</em>,
<tt>:variablename</tt>).</p>
</dd><dt><em>{block}</em></dt>
<dd>
<p>If a block is supplied, its return value must be a string, which will be
used as the name of the memcached cell backing the variable.  The argument
to the block is the name of the variable as passed to the accessor
declaration.</p>
</dd></dl>

<h3>Exceptions</h3>

<p><em>None.</em></p>
            

            
            <div class="method-source-code" id="memcached_reader-source">
<pre>
<span class="ruby-comment"># File lib/instantcache.rb, line 318</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">memcached_reader</span>(*<span class="ruby-identifier">args</span>, &amp;<span class="ruby-identifier">block</span>) ; <span class="ruby-keyword">end</span></pre>
            </div><!-- memcached_reader-source -->
            
          </div>

          

          
        </div><!-- memcached_reader-method -->

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">new(<i>[val]</i>)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <h3>Description</h3>

<p>Constructor for a normal (<em>i.e.</em>, non-counter) variable stored in
the cache.  This is not intended to be invoked directly except by Those Who
Know What They’re Doing; rather, cached variables should be declared with
the accessor methods <tt>Blob#memcached_accessor</tt> (for read/write
access) and <tt>Blob#memcached_reader</tt> (for read-only).</p>

<h3>Arguments</h3>
<dl class="rdoc-list"><dt><em>val</em></dt>
<dd>
<p>Value to be loaded into the cache cell. <b>N.B.:</b> If the cell in
question is shared, this <b>will</b> overwrite the current value if any!</p>
</dd></dl>

<h3>Exceptions</h3>

<p><em>None.</em></p>
            

            
            <div class="method-source-code" id="new-source">
<pre>
<span class="ruby-comment"># File lib/instantcache.rb, line 377</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">inival</span>=<span class="ruby-keyword">nil</span>)
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># This method is defined in the Blob class, for which raw mode</span>
  <span class="ruby-comment"># is a no-no.  However, to allow simple subclassing, we only set</span>
  <span class="ruby-comment"># @rawmode if a potential subclass' #initialize hasn't done so.</span>
  <span class="ruby-comment"># Thus subclasses can get most of the setup work done with a</span>
  <span class="ruby-comment"># simple invocation of #super.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-ivar">@rawmode</span> = <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> (<span class="ruby-ivar">@rawmode</span>.<span class="ruby-identifier">nil?</span>)
  <span class="ruby-ivar">@expiry</span> = <span class="ruby-value">0</span>
  <span class="ruby-ivar">@locked_by_us</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Fill in our identity for purposes of lock ownership.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-ivar">@identity</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">create_identity</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># If we were given an initial value, go ahead and store it.</span>
  <span class="ruby-comment"># &lt;b&gt;N.B.:&lt;/b&gt; If the cell in question is shared, this</span>
  <span class="ruby-comment"># &lt;b&gt;will&lt;/b&gt; overwrite the current value if any!</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">set</span>(<span class="ruby-identifier">inival</span>) <span class="ruby-keyword">unless</span>(<span class="ruby-identifier">inival</span>.<span class="ruby-identifier">nil?</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->

      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="create_identity-method" class="method-detail ">
          <a name="method-i-create_identity"></a>

          
          <div class="method-heading">
            <span class="method-name">create_identity</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <h3>Description</h3>

<p>Create a string that should uniquely identify this instance and a way to
locate it.  This is stored in the interlock cell when we obtain exclusive
access to the main cached cell, so that we can be tracked down in case of
hangs or other problems.</p>

<p>This method can be overridden at need.</p>

<h3>Arguments</h3>

<p><em>None.</em></p>

<h3>Exceptions</h3>
<dl class="rdoc-list"><dt><tt><a href="Destroyed.html">InstantCache::Destroyed</a></tt></dt>
<dd>
<p>Cache value instance has been destroyed and is no longer usable. The value
in the cache is unaffected.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="create_identity-source">
<pre>
<span class="ruby-comment"># File lib/instantcache.rb, line 417</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">create_identity</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Destroyed</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">name</span>) <span class="ruby-keyword">if</span> (<span class="ruby-keyword">self</span>.<span class="ruby-identifier">destroyed?</span>)
  <span class="ruby-identifier">idfmt</span> = <span class="ruby-string">'host[%s]:pid[%d]:thread[%d]:%s[%d]'</span>
  <span class="ruby-identifier">idargs</span> = []
  <span class="ruby-identifier">idargs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">`hostname`</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">strip</span>
  <span class="ruby-identifier">idargs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">$$</span>
  <span class="ruby-identifier">idargs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">object_id</span>
  <span class="ruby-identifier">idargs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-regexp">%^.*::!</span>, <span class="ruby-string">''</span>)
  <span class="ruby-identifier">idargs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">object_id</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">idfmt</span> <span class="ruby-operator">%</span> <span class="ruby-identifier">idargs</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- create_identity-source -->
            
          </div>

          

          
        </div><!-- create_identity-method -->

      
        <div id="destroy-21-method" class="method-detail ">
          <a name="method-i-destroy-21"></a>

          
          <div class="method-heading">
            <span class="method-name">destroy!</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <h3>Description</h3>

<p>Marks this instance as <b>destroyed</b> – that is to say, any connexion
it has to any cached value is severed.  Any outstanding lock on the cache
entry is released.  This instance will no longer be usable.</p>

<h3>Arguments</h3>

<p><em>None.</em></p>

<h3>Exceptions</h3>
<dl class="rdoc-list"><dt><tt><a href="Destroyed.html">InstantCache::Destroyed</a></tt></dt>
<dd>
<p>Cache value instance has been destroyed and is no longer usable. The value
in the cache is unaffected.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="destroy-21-source">
<pre>
<span class="ruby-comment"># File lib/instantcache.rb, line 514</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">destroy!</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Destroyed</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">name</span>) <span class="ruby-keyword">if</span> (<span class="ruby-keyword">self</span>.<span class="ruby-identifier">destroyed?</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">unlock</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">instance_eval</span>(<span class="ruby-string">'def destroyed? ; return true ; end'</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- destroy-21-source -->
            
          </div>

          

          
        </div><!-- destroy-21-method -->

      
        <div id="destroyed-3F-method" class="method-detail ">
          <a name="method-i-destroyed-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">destroyed?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <h3>Description</h3>

<p>Returns true or false according to whether this variable instance has been
irrevocably disconnected from any value in the cache.</p>

<p>When the instance is destroyed, this method is redefined to return
<em>true</em>.</p>

<h3>Arguments</h3>

<p><em>None.</em></p>

<h3>Exceptions</h3>

<p><em>None.</em></p>
            

            
            <div class="method-source-code" id="destroyed-3F-source">
<pre>
<span class="ruby-comment"># File lib/instantcache.rb, line 495</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">destroyed?</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- destroyed-3F-source -->
            
          </div>

          

          
        </div><!-- destroyed-3F-method -->

      
        <div id="get-method" class="method-detail ">
          <a name="method-i-get"></a>

          
          <div class="method-heading">
            <span class="method-name">get</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <h3>Description</h3>

<p>Fetch the value out of memcached.  Before being returned to the called, the
value is annotated with singleton methods intended to keep the cache
updated with any changes made to the value we’re returning.</p>

<h3>Arguments</h3>

<p><em>None.</em></p>

<h3>Exceptions</h3>
<dl class="rdoc-list"><dt><tt><a href="Destroyed.html">InstantCache::Destroyed</a></tt></dt>
<dd>
<p>Cache value instance has been destroyed and is no longer usable. The value
in the cache is unaffected.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="get-source">
<pre>
<span class="ruby-comment"># File lib/instantcache.rb, line 653</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Destroyed</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">name</span>) <span class="ruby-keyword">if</span> (<span class="ruby-keyword">self</span>.<span class="ruby-identifier">destroyed?</span>)
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># TODO: Another instance of poor-man's-cache-location; see #reset</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-identifier">value</span> = <span class="ruby-constant">InstantCache</span>.<span class="ruby-identifier">cache_object</span>.<span class="ruby-identifier">get</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">name</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">rawmode</span>)
  <span class="ruby-keyword">begin</span>
    <span class="ruby-comment">#</span>
    <span class="ruby-comment"># Make a copy of the thing we fetched out of the cache.</span>
    <span class="ruby-comment">#</span>
    <span class="ruby-identifier">value</span>.<span class="ruby-identifier">clone</span>
    <span class="ruby-comment">#</span>
    <span class="ruby-comment"># Add a note to it about who we are (so that requests can be</span>
    <span class="ruby-comment"># appropriately directed).</span>
    <span class="ruby-comment">#</span>
    <span class="ruby-identifier">value</span>.<span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-value">:@_instantcache_owner</span>, <span class="ruby-keyword">self</span>)
    <span class="ruby-comment">#</span>
    <span class="ruby-comment"># Add the singleton annotations.</span>
    <span class="ruby-comment">#</span>
    <span class="ruby-constant">InstantCache</span>.<span class="ruby-identifier">enwrap</span>(<span class="ruby-identifier">value</span>)
  <span class="ruby-keyword">rescue</span>
    <span class="ruby-comment">#</span>
    <span class="ruby-comment"># If the value was something we couldn't clone, like a Fixnum,</span>
    <span class="ruby-comment"># it's inherently immutable and we don't need to add no</span>
    <span class="ruby-comment"># steenkin' singleton methods to it.  That's our position</span>
    <span class="ruby-comment"># ayup.</span>
    <span class="ruby-comment">#</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- get-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="Blob.html#method-i-read">read</a>
          </div>
          

          
        </div><!-- get-method -->

      
        <div id="lock-method" class="method-detail ">
          <a name="method-i-lock"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">lock => <i>Boolean</i></span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <h3>Description</h3>

<p>Try to obtain an interlock on the memcached cell.  If successful, returns
true – else, the cell is locked by someone else and we should proceed
accordingly.</p>

<p><b>N.B.:</b> This makes use of the memcached convention that #add is a
no-op if the cell already exists; we use that to try to create the
interlock cell.</p>

<p>The return value is wither <b><tt>true</tt></b> if we obtained (or already
held) an exclusive lock, or <b><tt>false</tt></b> if we failed and/or
someone else has it locked exclusively.</p>

<h3>Arguments</h3>

<p><em>None.</em></p>

<h3>Exceptions</h3>
<dl class="rdoc-list"><dt><tt><a href="Destroyed.html">InstantCache::Destroyed</a></tt></dt>
<dd>
<p>Cache value instance has been destroyed and is no longer usable. The value
in the cache is unaffected.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="lock-source">
<pre>
<span class="ruby-comment"># File lib/instantcache.rb, line 566</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">lock</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Destroyed</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">name</span>) <span class="ruby-keyword">if</span> (<span class="ruby-keyword">self</span>.<span class="ruby-identifier">destroyed?</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span> <span class="ruby-keyword">if</span> (<span class="ruby-ivar">@locked_by_us</span>)
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># TODO: Another instance of poor-man's-cache-location; see #reset</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-identifier">sts</span> = <span class="ruby-constant">InstantCache</span>.<span class="ruby-identifier">cache_object</span>.<span class="ruby-identifier">add</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">lock_name</span>, <span class="ruby-ivar">@identity</span>)
  <span class="ruby-ivar">@locked_by_us</span> = (<span class="ruby-identifier">sts</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">%^STORED!</span>) <span class="ruby-operator">?</span> <span class="ruby-keyword">true</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">return</span> <span class="ruby-ivar">@locked_by_us</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- lock-source -->
            
          </div>

          

          
        </div><!-- lock-method -->

      
        <div id="name-method" class="method-detail ">
          <a name="method-i-name"></a>

          
          <div class="method-heading">
            <span class="method-name">name</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <h3>Description</h3>

<p>The name of the variable declared with #memcached_accessor and friends does
<em>not</em> necessarily equate to the name of the cell in the cache.  This
method is responsible for creating the latter; the name it returns is also
used to identify the interlock cell.</p>

<p>This method <b>must</b> be overridden by subclassing; there is no default
name syntax for the memcache cells.  (This is done automatically by the
<tt>memcached_<em>xxx</em></tt> accessor declarations.)</p>

<h3>Arguments</h3>

<p><em>None.</em></p>

<h3>Exceptions</h3>
<dl class="rdoc-list"><dt><tt>RuntimeError</tt></dt>
<dd>
<p>This method has not been overridden as required.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="name-source">
<pre>
<span class="ruby-comment"># File lib/instantcache.rb, line 476</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">name</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">RuntimeError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'#name method must be defined in instance'</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- name-source -->
            
          </div>

          

          
        </div><!-- name-method -->

      
        <div id="read-method" class="method-detail method-alias">
          <a name="method-i-read"></a>

          
          <div class="method-heading">
            <span class="method-name">read</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="Blob.html#method-i-get">get</a>
          </div>
          
        </div><!-- read-method -->

      
        <div id="reset-method" class="method-detail ">
          <a name="method-i-reset"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reset => <i>default reset value</i></span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <h3>Description</h3>

<p>Reset the cache value to its default (typically zero or nil).</p>

<h3>Arguments</h3>

<p><em>None.</em></p>

<h3>Exceptions</h3>
<dl class="rdoc-list"><dt><tt><a href="Destroyed.html">InstantCache::Destroyed</a></tt></dt>
<dd>
<p>Cache value instance has been destroyed and is no longer usable. The value
in the cache is unaffected.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="reset-source">
<pre>
<span class="ruby-comment"># File lib/instantcache.rb, line 444</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">reset</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Destroyed</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">name</span>) <span class="ruby-keyword">if</span> (<span class="ruby-keyword">self</span>.<span class="ruby-identifier">destroyed?</span>)
  <span class="ruby-identifier">rval</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">if</span> (<span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">constants</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">'RESET_VALUE'</span>))
    <span class="ruby-identifier">rval</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">const_get</span>(<span class="ruby-string">'RESET_VALUE'</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># TODO: This can mess with subclassing; need better way to find the cache</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-constant">InstantCache</span>.<span class="ruby-identifier">cache_object</span>.<span class="ruby-identifier">set</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">rval</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">expiry</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">rawmode</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">rval</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- reset-source -->
            
          </div>

          

          
        </div><!-- reset-method -->

      
        <div id="set-method" class="method-detail ">
          <a name="method-i-set"></a>

          
          <div class="method-heading">
            <span class="method-name">set</span><span
              class="method-args">(val_p)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <h3>Description</h3>

<p>Store a value for the cell into the cache.  We need to remove any singleton
annotation methods before storing because the memcache gem can’t handle
them (actually, Marshal#dump, which memcache uses, cannot handle them).</p>

<p><em>N.B.:</em> We <b>don’t</b> remove any annotations from the original
value; it might be altered again, in which case we’d want to update the
cache again.  This can lead to some odd situations; see the bug list.</p>

<h3>Arguments</h3>
<dl class="rdoc-list"><dt><em>val_p</em></dt>
<dd>
<p>The new value to be stored.</p>
</dd></dl>

<h3>Exceptions</h3>
<dl class="rdoc-list"><dt><tt><a href="Destroyed.html">InstantCache::Destroyed</a></tt></dt>
<dd>
<p>Cache value instance has been destroyed and is no longer usable. The value
in the cache is unaffected.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="set-source">
<pre>
<span class="ruby-comment"># File lib/instantcache.rb, line 705</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set</span>(<span class="ruby-identifier">val_p</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Destroyed</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">name</span>) <span class="ruby-keyword">if</span> (<span class="ruby-keyword">self</span>.<span class="ruby-identifier">destroyed?</span>)
  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">val</span> = <span class="ruby-identifier">val_p</span>.<span class="ruby-identifier">clone</span>
  <span class="ruby-keyword">rescue</span> <span class="ruby-constant">TypeError</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
    <span class="ruby-identifier">val</span> = <span class="ruby-identifier">val_p</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-constant">InstantCache</span>.<span class="ruby-identifier">unwrap</span>(<span class="ruby-identifier">val</span>)
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># TODO: Another instance of poor-man's-cache-location; see #reset</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># We use both memcache#add and memcache#set for completeness.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-constant">InstantCache</span>.<span class="ruby-identifier">cache_object</span>.<span class="ruby-identifier">add</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">val</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">expiry</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">rawmode</span>)
  <span class="ruby-constant">InstantCache</span>.<span class="ruby-identifier">cache_object</span>.<span class="ruby-identifier">set</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">val</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">expiry</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">rawmode</span>)
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Return the value as fetched through our accessor; this ensures</span>
  <span class="ruby-comment"># the proper annotation.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">get</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- set-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="Blob.html#method-i-write">write</a>
          </div>
          

          
        </div><!-- set-method -->

      
        <div id="to_s-method" class="method-detail ">
          <a name="method-i-to_s"></a>

          
          <div class="method-heading">
            <span class="method-name">to_s</span><span
              class="method-args">(*args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <h3>Description</h3>

<p>Return the string representaton of the value, not this instance. This is
part of our ‘try to be transparent’ sensitivity training.</p>

<h3>Arguments</h3>

<p>Any appropriate to the <a href="Blob.html#method-i-to_s">to_s</a> method of
the underlying data’s class.</p>

<h3>Exceptions</h3>
<dl class="rdoc-list"><dt><tt><a href="Destroyed.html">InstantCache::Destroyed</a></tt></dt>
<dd>
<p>Cache value instance has been destroyed and is no longer usable. The value
in the cache is unaffected.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="to_s-source">
<pre>
<span class="ruby-comment"># File lib/instantcache.rb, line 743</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_s</span>(*<span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Destroyed</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">name</span>) <span class="ruby-keyword">if</span> (<span class="ruby-keyword">self</span>.<span class="ruby-identifier">destroyed?</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">get</span>.<span class="ruby-identifier">__send__</span>(<span class="ruby-value">:to_s</span>, *<span class="ruby-identifier">args</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- to_s-source -->
            
          </div>

          

          
        </div><!-- to_s-method -->

      
        <div id="unlock-method" class="method-detail ">
          <a name="method-i-unlock"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">unlock => <i>Boolean</i></span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <h3>Description</h3>

<p>If we have the cell locked, unlock it by deleting the interlock cell
(allowing someone else’s <a href="Blob.html#method-i-lock">lock</a>(#add)
to work).</p>

<p>This method returns <tt>true</tt> if we held the lock and have released it,
or false if we didn’t own the lock or the cell isn’t locked at all.</p>

<h3>Arguments</h3>

<p><em>None.</em></p>

<h3>Exceptions</h3>
<dl class="rdoc-list"><dt><tt><a href="Destroyed.html">InstantCache::Destroyed</a></tt></dt>
<dd>
<p>Cache value instance has been destroyed and is no longer usable. The value
in the cache is unaffected.</p>
</dd><dt><tt><a href="LockInconsistency.html">InstantCache::LockInconsistency</a></tt></dt>
<dd>
<p>The state of the lock on the cell as stored in memcache differs from our
local understanding of things. Specifically, we show it as locked by us,
but the cache disagrees.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="unlock-source">
<pre>
<span class="ruby-comment"># File lib/instantcache.rb, line 607</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">unlock</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Destroyed</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">name</span>) <span class="ruby-keyword">if</span> (<span class="ruby-keyword">self</span>.<span class="ruby-identifier">destroyed?</span>)
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># TODO: Another instance of poor-man's-cache-location; see #reset</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-identifier">sts</span> = <span class="ruby-constant">InstantCache</span>.<span class="ruby-identifier">cache_object</span>.<span class="ruby-identifier">get</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">lock_name</span>) <span class="ruby-operator">||</span> <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">if</span> (<span class="ruby-ivar">@locked_by_us</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">sts</span> <span class="ruby-operator">!=</span> <span class="ruby-ivar">@identity</span>))
    <span class="ruby-comment">#</span>
    <span class="ruby-comment"># If we show we have the lock, but the lock cell doesn't exist</span>
    <span class="ruby-comment"># (or isn't us), that's definitely an inconsistency.</span>
    <span class="ruby-comment">#</span>
    <span class="ruby-identifier">e</span> = <span class="ruby-constant">LockInconsistency</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">lock_name</span>,
                              <span class="ruby-ivar">@identity</span>,
                              <span class="ruby-identifier">sts</span>.<span class="ruby-identifier">inspect</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-identifier">e</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> (<span class="ruby-ivar">@locked_by_us</span>)
  <span class="ruby-ivar">@locked_by_us</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># TODO: Another instance of poor-man's-cache-location; see #reset</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-identifier">sts</span> = <span class="ruby-constant">InstantCache</span>.<span class="ruby-identifier">cache_object</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">lock_name</span>)
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">sts</span> <span class="ruby-operator">!~</span> <span class="ruby-regexp">%^DELETED!</span>)
    <span class="ruby-identifier">e</span> = <span class="ruby-constant">LockInconsistency</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">lock_name</span>,
                              <span class="ruby-string">'/DELETED/'</span>,
                              <span class="ruby-identifier">sts</span>.<span class="ruby-identifier">inspect</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-identifier">e</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- unlock-source -->
            
          </div>

          

          
        </div><!-- unlock-method -->

      
        <div id="write-method" class="method-detail method-alias">
          <a name="method-i-write"></a>

          
          <div class="method-heading">
            <span class="method-name">write</span><span
              class="method-args">(val_p)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="Blob.html#method-i-set">set</a>
          </div>
          
        </div><!-- write-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  

  </div><!-- documentation -->

  <div id="validator-badges">
    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
    <p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
      Rdoc Generator</a> 2</small>.</p>
  </div>

</body>
</html>

